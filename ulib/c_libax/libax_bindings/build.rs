extern crate cbindgen;

use std::{env, path::Path};

fn main() {
    println!("cargo:rerun-if-changed=../include/sys/stat.h");

    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let config = cbindgen::Config {
        language: cbindgen::Language::C,
        cpp_compat: true,
        no_includes: false,
        usize_is_size_t: true,
        style: cbindgen::Style::Tag,
        sys_includes: vec![String::from("sys/types.h")],
        header: Some("/* Generated by cbindgen and build.rs, DO NOT edit! */".into()),
        ..Default::default()
    };

    cbindgen::generate_with_config(&crate_dir, config)
        .expect("Unable to generate bindings")
        .write_to_file("libax.h");

    let include_dir = Path::new(&env::var("CARGO_MANIFEST_DIR").unwrap()).join("../include");

    // The bindgen::Builder is the main entry point
    // to bindgen, and lets you build up options for
    // the resulting bindings.
    let bindings = bindgen::Builder::default()
        // The input header we would like to generate
        // bindings for.
        .header(env::var("CARGO_MANIFEST_DIR").unwrap() + "/../include/sys/stat.h")
        // Set the include folder.
        .clang_arg(format!("-I{}", include_dir.to_str().unwrap()))
        // Tell cargo to invalidate the built crate whenever any of the
        // included header files changed.
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        // Use allowlist_type or ... to add item into whitelist.
        // Just generate the type and functions in the whitelist.
        .allowlist_type("stat")
        // Use core::ffi::* insteads of std::ffi::*.
        .use_core()
        // Finish the builder and generate the bindings.
        .generate()
        // Unwrap the Result and panic on failure.
        .expect("Unable to generate bindings");

    // Write the bindings to the libax_bindings/bindings.rs file.
    bindings
        .write_to_file(Path::new(&crate_dir).join("bindings.rs"))
        .expect("Couldn't write bindings!");
}
